#!/usr/bin/python3
#+
# Test of trying to parse the contents of .blend files.
#
# Created by Lawrence D'Oliveiro <ldo@geek-central.gen.nz>.
#-

import sys
import os
import struct

#+
# Useful stuff
#-

def structread(fromfile, decode_struct) :
    """reads sufficient bytes from fromfile to be unpacked according to
    decode_struct, and returns the unpacked results."""
    return struct.unpack(decode_struct, fromfile.read(struct.calcsize(decode_struct)))
#end structread

#+
# Representation of more complex Blender types
#-

class PointerType :
    # represents a pointer

    def __init__(self, EltType) :
        self.EltType = EltType
    #end __init__

#end PointerType

class FixedArrayType :
    # represents a fixed-length array

    def __init__(self, EltType, NrElts) :
        self.EltType = EltType
        self.NrElts = NrElts
    #end __init__

#end FixedArrayType :

class MethodType :
    # represents a pointer to a routine

    def __init__(self, ResultType) :
        self.ResultType = ResultType
    #end __init__

#end MethodType

def parse_field_type(field_name, field_type) :
    if field_name[0] == "*" :
        field_name, field_type = parse_field_type(field_name[1:], PointerType(field_type))
    elif field_name[:2] == "(*" and field_name[-3:] == ")()" :
        field_name, field_type = parse_field_type(field_name[2:-3], MethodType(field_type))
    else :
        indexstart = field_name.rfind("[")
        if indexstart >= 0 :
            assert field_name[-1] == "]", "%s does not end with ]" % repr(field_name)
            nr_elts = int(field_name[indexstart + 1 : -1])
            field_name, field_type = parse_field_type(field_name[:indexstart], field_type)
            field_type = FixedArrayType(field_type, nr_elts)
        #end if
    #end if
    return \
        field_name, field_type
#end parse_field_type

def type_name(of_type) :
    if type(of_type) == PointerType :
        result = type_name(of_type.EltType) + "*"
    elif type(of_type) == FixedArrayType :
        result = "%s[%d]" % (type_name(of_type.EltType), of_type.NrElts)
    elif type(of_type) == MethodType :
        result = "%s (*)()" % type_name(of_type.ResultType)
    else :
        result = of_type["name"]
    #end if
    return \
        result
#end type_name

#+
# Mainline
#-

if len(sys.argv) != 2 :
    raise RuntimeError("need one arg, the name of the .blend file to parse")
#end if
fd = open(sys.argv[1], "rb")
sig, ptrcode, endiancode, version = structread(fd, "7s1s1s3s")
assert sig == b"BLENDER", "unrecognized file header signature %s" % sig
ptrsize = {b"_" : 4, b"-" : 8}[ptrcode]
ptrcode = {b"_" : "L", b"-" : "Q"}[ptrcode]
endian = {b"v" : "<", b"V" : ">"}[endiancode]
blocks = []
while True :
    blockcode, datasize, oldaddr, dna_index, dna_count = \
        structread(fd, "%s4sI%sII" % (endian, ptrcode))
    sys.stdout.write("blockcode = %s, datasize = %d, oldattr = %x, dna_index = %d, dna_count = %d\n" % (blockcode, datasize, oldaddr, dna_index, dna_count)) # debug
    if blockcode == b"DNA1" :
        sdna_data = fd.read(datasize)
        sdna_id = sdna_data[:4]
        assert sdna_id == b"SDNA", "invalid DNA block header"
        sdna_data = sdna_data[4:]
        names = []
        types = []
        structs = []
        data_offset = 4
        for \
            expect_id, collect \
        in \
            (
                (b"NAME", names),
                (b"TYPE", types),
            ) \
        :
            assert len(sdna_data) >= 8, "premature end of DNA block"
            assert expect_id == sdna_data[:4], "expecting %s sub-block in DNA block" % expect_id
            nr_names = struct.unpack(endian + "I", sdna_data[4:8])[0]
            sdna_data = sdna_data[8:]
            data_offset += 8
            for i in range(0, nr_names) :
                str_end = sdna_data.index(b"\0")
                collect.append(sdna_data[:str_end].decode("utf-8"))
                sys.stdout.write("name[%d] = %s\n" % (i, repr(collect[i]))) # debug
                data_offset += str_end + 1
                sdna_data = sdna_data[str_end + 1:]
            #end for
            if data_offset % 4 != 0 :
                sdna_data = sdna_data[4 - data_offset % 4:]
                data_offset += 4 - data_offset % 4
            #end if
        #end for
        for i in range(0, len(types)) :
            types[i] = {"name" : types[i]}
        #end for
        assert sdna_data[:4] == b"TLEN", "expecting TLEN sub-block in DNA block"
        sdna_data = sdna_data[4:]
        data_offset += 4
        for i, s in enumerate(struct.unpack(endian + "H" * len(types), sdna_data[:2 * len(types)])) :
            types[i]["size"] = s
            sys.stdout.write("sizeof(%s) = %d\n" % (types[i]["name"], types[i]["size"])) # debug
        #end for
        sdna_data = sdna_data[2 * len(types):]
        data_offset += 2 * len(types)
        if data_offset % 4 != 0 :
            sdna_data = sdna_data[4 - data_offset % 4:]
            data_offset += 4 - data_offset % 4
        #end if
        assert sdna_data[:4] == b"STRC", "expecting STRC sub-block in DNA block"
        nr_structs = struct.unpack(endian + "I", sdna_data[4:8])[0]
        sdna_data = sdna_data[8:]
        data_offset += 8
        for i in range(0, nr_structs) :
            struct_type, nr_fields = struct.unpack(endian + "HH", sdna_data[:4])
            sdna_data = sdna_data[4:]
            fields = []
            for j, f in enumerate(struct.unpack(endian + "HH" * nr_fields, sdna_data[:4 * nr_fields])) :
                if j % 2 == 0 :
                    field_type = f
                else :
                    field_name, field_type = parse_field_type(names[f], types[field_type])
                    fields.append({"type" : field_type, "name" : field_name})
                    sys.stdout.write("%s.%s : %s\n" % (types[struct_type]["name"], field_name, type_name(field_type))) # debug
                #end if
            #end for
            types[struct_type]["fields"] = fields
            if len(structs) < i + 1 :
                structs.extend([None] * (i + 1 - len(structs)))
            #end if
            structs[i] = types[struct_type]
            sys.stdout.write("struct[%d] is %s\n" % (i, types[struct_type]["name"])) # debug
            sdna_data = sdna_data[4 * nr_fields:]
        #end for
    elif blockcode == b"ENDB" :
        break
    else :
        blocks.append \
          (
            {
                "code" : blockcode,
                "oldaddr" : oldaddr,
                "dna_index" : dna_index,
                "dna_count" : dna_count,
                "data" : fd.read(datasize),
            }
          )
    #end if
#end while
fd.close()
for i, block in enumerate(blocks) :
    sys.stdout.write("block %d(%s)[%s] : %s[%d]\n" % (i, repr(block["code"]), len(block["data"]), structs[block["dna_index"]]["name"], block["dna_count"])) # debug
#end for
# more TBD
