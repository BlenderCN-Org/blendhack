#!/usr/bin/python3
#+
# Test of trying to parse the contents of .blend files.
#
# Created by Lawrence D'Oliveiro <ldo@geek-central.gen.nz>.
#-

import sys
import os
import struct

#+
# Useful stuff
#-

def structread(fromfile, decode_struct) :
    """reads sufficient bytes from fromfile to be unpacked according to
    decode_struct, and returns the unpacked results."""
    return struct.unpack(decode_struct, fromfile.read(struct.calcsize(decode_struct)))
#end structread

class DanglingPointer :
    # for showing pointers that don't seem to point to any valid block

    def __init__(self, addr) :
        self.addr = addr
    #end __init__

    def __repr__(self) :
        return "DanglingPointer(0x%x)" % self.addr
    #end __repr__

#end DanglingPointer

class RoutineAddr :
    # for showing pointers to methods

    def __init__(self, addr) :
        self.addr = addr
    #end __init__

    def __repr__(self) :
        return "RoutineAddr(0x%x)" % self.addr
    #end __repr__

#end RoutineAddr

class BlockIndex :
    # for showing references to other blocks

    def __init__(self, index) :
        self.index = index
    #end __init__

    def __repr__(self) :
        return "*Block[%d]" % self.index
    #end __repr__

#end BlockIndex

#+
# Handling of Blender types
#-

class PointerType :
    # represents a pointer

    def __init__(self, EltType) :
        self.EltType = EltType
    #end __init__

#end PointerType

class FixedArrayType :
    # represents a fixed-length array

    def __init__(self, EltType, NrElts) :
        self.EltType = EltType
        self.NrElts = NrElts
    #end __init__

#end FixedArrayType :

class MethodType :
    # represents a pointer to a routine

    def __init__(self, ResultType) :
        self.ResultType = ResultType
    #end __init__

#end MethodType

def parse_field_type(field_name, field_type) :
    # processes special forms of field_name ("*name", "name[ind]", "(*name)()"),
    # returning inner name and adjusting field_type accordingly.
    if len(field_name) != 0 and field_name[0] == "*" :
        field_name, field_type = parse_field_type(field_name[1:], PointerType(field_type))
    elif field_name[:2] == "(*" and field_name[-3:] == ")()" :
        field_name, field_type = parse_field_type(field_name[2:-3], MethodType(field_type))
    else :
        indexstart = field_name.rfind("[")
        if indexstart >= 0 :
            assert field_name[-1] == "]", "%s does not end with ]" % repr(field_name)
            nr_elts = int(field_name[indexstart + 1 : -1])
            field_name, field_type = parse_field_type(field_name[:indexstart], field_type)
            field_type = FixedArrayType(field_type, nr_elts)
        #end if
    #end if
    return \
        field_name, field_type
#end parse_field_type

def type_name(of_type) :
    # returns a readable display of of_type.
    if type(of_type) == PointerType :
        result = type_name(of_type.EltType) + "*"
    elif type(of_type) == FixedArrayType :
        result = "%s[%d]" % (type_name(of_type.EltType), of_type.NrElts)
    elif type(of_type) == MethodType :
        result = "%s (*)()" % type_name(of_type.ResultType)
    else :
        result = of_type["name"]
    #end if
    return \
        result
#end type_name

def type_size(of_type) :
    # determines the size in bytes of objects of type of_type.
    if type(of_type) == PointerType :
        result = ptrsize
    elif type(of_type) == FixedArrayType :
        result = type_size(of_type.EltType) * of_type.NrElts
    elif type(of_type) == MethodType :
        result = ptrsize
    else :
        result = of_type["size"]
    #end if
    return \
        result
#end type_size

primitive_types = \
    {
        "char" : {"code" : "c", "size" : 1},
        "uchar" : {"code" : "B", "size" : 1},
        "short" : {"code" : "h", "size" : 2},
        "ushort" : {"code" : "H", "size" : 2},
        "int" : {"code" : "i", "size" : 4},
        "long" : {"code" : "l", "size" : 4},
        "ulong" : {"code" : "L", "size" : 4},
        "float" : {"code" : "f", "size" : 4},
        "double" : {"code" : "d", "size" : 8},
        "int64_t" : {"code" : "q", "size" : 8}, # might not be present
        "uint64_t" : {"code" : "Q", "size" : 8}, # might not be present
        "void" : {"size" : 0}, # only occurs as pointer object type!
    }

def decode_data(rawdata, datatype) :
    # decodes the bytes of rawdata to Python form according to the type datatype.
    if type(datatype) == PointerType :
        assert len(rawdata) == ptrsize, "expecting pointer to be %d bytes, got %d" % (ptrsize, len(rawdata))
        oldaddress = struct.unpack(endian + ptrcode, rawdata)[0]
        if oldaddress == 0 :
            result = None
        elif oldaddress in blocks_by_oldaddress :
            # result = blocks_by_oldaddress[oldaddress]
            result = BlockIndex(blocks_by_oldaddress[oldaddress]["index"]) # less cluttered display
        else :
            result = DanglingPointer(oldaddress)
        #end if
    elif type(datatype) == FixedArrayType :
        result = []
        elt_size = type_size(datatype.EltType)
        assert len(rawdata) == elt_size * datatype.NrElts
        for i in range(0, datatype.NrElts) :
            result.append(decode_data(rawdata[i * elt_size : (i + 1) * elt_size], datatype.EltType))
        #end for
        if datatype.EltType == types["char"] :
            # prettier display
            result = b"".join(result).rstrip(b"\0")
            try :
                result = result.decode("utf-8")
            except UnicodeDecodeError :
                pass # leave as bytes
            #end try
        #end if
    elif type(datatype) == MethodType :
        assert len(rawdata) == ptrsize, "expecting method pointer to be %d bytes, got %d" % (ptrsize, len(rawdata))
        addr = struct.unpack(endian + ptrcode, rawdata)[0]
        if addr != 0 :
            result = RoutineAddr(addr)
              # show value just out of curiosity, saved value on disk can't possibly be useful
        else :
            result = None
        #end if
    elif datatype["name"] in primitive_types :
        assert len(rawdata) == primitive_types[datatype["name"]]["size"], "wrong size for primitive data of type %s, expected %d, got %d" % (datatype["name"], primitive_types[datatype["name"]]["size"], len(rawdata))
        result = struct.unpack(endian + primitive_types[datatype["name"]]["code"], rawdata)[0]
    else :
        assert "fields" in datatype, "non-primitive type %s has no fields" % datatype["name"]
        result = {}
        for field in datatype["fields"] :
            field_size = type_size(field["type"])
            if len(rawdata) < field_size :
                sys.stdout.write("# need at least %d bytes for %s.%s, only got %d\n" % (field_size, datatype["name"], field["name"], len(rawdata)))
                rawdata = b"" # ignore rest
                break
            #end if
            result[field["name"]] = decode_data(rawdata[:field_size], field["type"])
            rawdata = rawdata[field_size:]
        #end for
        assert len(rawdata) == 0, "leftover data after decoding %s struct" % datatype["name"]
    #end if
    return \
        result
#end decode_data

#+
# Mainline
#-

if len(sys.argv) != 2 :
    raise RuntimeError("need one arg, the name of the .blend file to parse")
#end if
fd = open(sys.argv[1], "rb")
sig, ptrcode, endiancode, version = structread(fd, "7s1s1s3s")
assert sig == b"BLENDER", "unrecognized file header signature %s" % sig
ptrsize = {b"_" : 4, b"-" : 8}[ptrcode]
ptrcode = {b"_" : "L", b"-" : "Q"}[ptrcode]
endian = {b"v" : "<", b"V" : ">"}[endiancode]
blocks = []
blocks_by_oldaddress = {}
global_block = None
while True :
    # collect all the blocks
    blockcode, datasize, oldaddr, dna_index, dna_count = \
        structread(fd, "%s4sI%sII" % (endian, ptrcode))
    sys.stdout.write("blockcode = %s, datasize = %d, oldattr = 0x%x, dna_index = %d, dna_count = %d\n" % (blockcode, datasize, oldaddr, dna_index, dna_count)) # debug
    if blockcode == b"DNA1" :
        # decode the structure definitions
        sdna_data = fd.read(datasize)
        sdna_id = sdna_data[:4]
        assert sdna_id == b"SDNA", "invalid DNA block header"
        sdna_data = sdna_data[4:]
        names = []
        types_by_index = []
        structs = []
        data_offset = 4
        for \
            expect_id, collect \
        in \
            (
                (b"NAME", names),
                (b"TYPE", types_by_index),
            ) \
        :
            assert len(sdna_data) >= 8, "premature end of DNA block"
            assert expect_id == sdna_data[:4], "expecting %s sub-block in DNA block" % expect_id
            nr_names = struct.unpack(endian + "I", sdna_data[4:8])[0]
            sdna_data = sdna_data[8:]
            data_offset += 8
            for i in range(0, nr_names) :
                str_end = sdna_data.index(b"\0")
                collect.append(sdna_data[:str_end].decode("utf-8"))
                sys.stdout.write("name[%d] = %s\n" % (i, repr(collect[i]))) # debug
                data_offset += str_end + 1
                sdna_data = sdna_data[str_end + 1:]
            #end for
            if data_offset % 4 != 0 :
                sdna_data = sdna_data[4 - data_offset % 4:]
                data_offset += 4 - data_offset % 4
            #end if
        #end for
        for i in range(0, len(types_by_index)) :
            types_by_index[i] = {"name" : types_by_index[i]}
        #end for
        assert sdna_data[:4] == b"TLEN", "expecting TLEN sub-block in DNA block"
        sdna_data = sdna_data[4:]
        data_offset += 4
        for i, s in enumerate(struct.unpack(endian + "H" * len(types_by_index), sdna_data[:2 * len(types_by_index)])) :
            types_by_index[i]["size"] = s
            sys.stdout.write("sizeof(%s) = %d\n" % (types_by_index[i]["name"], types_by_index[i]["size"])) # debug
        #end for
        sdna_data = sdna_data[2 * len(types_by_index):]
        data_offset += 2 * len(types_by_index)
        if data_offset % 4 != 0 :
            sdna_data = sdna_data[4 - data_offset % 4:]
            data_offset += 4 - data_offset % 4
        #end if
        assert sdna_data[:4] == b"STRC", "expecting STRC sub-block in DNA block"
        nr_structs = struct.unpack(endian + "I", sdna_data[4:8])[0]
        sdna_data = sdna_data[8:]
        data_offset += 8
        for i in range(0, nr_structs) :
            struct_type, nr_fields = struct.unpack(endian + "HH", sdna_data[:4])
            sdna_data = sdna_data[4:]
            fields = []
            for j, f in enumerate(struct.unpack(endian + "HH" * nr_fields, sdna_data[:4 * nr_fields])) :
                if j % 2 == 0 :
                    field_type = f
                else :
                    field_name, field_type = parse_field_type(names[f], types_by_index[field_type])
                    fields.append({"type" : field_type, "name" : field_name})
                    sys.stdout.write("%s.%s : %s\n" % (types_by_index[struct_type]["name"], field_name, type_name(field_type))) # debug
                #end if
            #end for
            types_by_index[struct_type]["fields"] = fields
            if len(structs) < i + 1 :
                structs.extend([None] * (i + 1 - len(structs)))
            #end if
            structs[i] = types_by_index[struct_type]
            sys.stdout.write("struct[%d] is %s\n" % (i, types_by_index[struct_type]["name"])) # debug
            sdna_data = sdna_data[4 * nr_fields:]
        #end for
        types = {}
        for t in types_by_index :
            assert (t["name"] in primitive_types) <= ("fields" not in t), "primitive type %s must not be struct" % t["name"]
            types[t["name"]] = t
        #end for
        for k in primitive_types :
            assert k not in types or primitive_types[k]["size"] == types[k]["size"], "wrong type size for primitive type %s, expected %d, got %d" % (k, primitive_types[k]["size"], types[k]["size"])
        #end for
    elif blockcode == b"ENDB" :
        # file-end marker block
        break
    else :
        new_block = \
            {
                "code" : blockcode,
                "oldaddr" : oldaddr,
                "dna_index" : dna_index,
                "dna_count" : dna_count,
                "rawdata" : fd.read(datasize),
                "index" : len(blocks),
            }
        if blockcode == b"GLOB" :
            assert global_block == None, "multiple GLOB blocks found"
            global_block = new_block
        #end if
        blocks.append(new_block)
        blocks_by_oldaddress[new_block["oldaddr"]] = new_block
    #end if
#end while
fd.close()
assert global_block != None, "missing GLOB block"
for i, block in enumerate(blocks) :
    block_type = structs[block["dna_index"]]
    sys.stdout.write("block %d(%s)[%s] : %s[%d]\n" % (i, repr(block["code"]), len(block["rawdata"]), block_type["name"], block["dna_count"])) # debug
    for j in range(0, block["dna_count"]) :
        sys.stdout.write(" => " + repr(decode_data(block["rawdata"][j * block_type["size"] : (j + 1) * block_type["size"]], block_type)) + "\n")
    #end for
#end for
