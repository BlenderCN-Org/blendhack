#!/usr/bin/python3
#+
# Test of trying to parse the contents of .blend files created by
# Blender <http://www.blender.org/>. Invoke this script as follows:
#
#     blendparse blendfile [outfile]
#
# where blendfile is the name of a .blend file to analyze, and outfile
# is an optional output .blend file to try creating.
# The output of the script will be a dump of the decoded file contents.
#
# Copyright 2012 Lawrence D'Oliveiro <ldo@geek-central.gen.nz>.
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#-

import sys
import getopt
import blendfile

def dict_repr(d) :
  # ensure dictionary items come out in consistent order
    if type(d) == dict :
        result = \
            (
                "{"
            +
                ", ".join(dict_repr(key) + ": " + dict_repr(d[key]) for key in sorted(d))
            +
                "}"
            )
    elif type(d) == tuple :
        result = "(" + ", ".join(dict_repr(item) for item in d) + ")"
    elif type(d) == list :
        result = "[" + ", ".join(dict_repr(item) for item in d) + "]"
    else :
        result = repr(d)
    #end if
    return \
        result
#end dict_repr

#+
# Mainline
#-

opts, args = getopt.getopt \
  (
    sys.argv[1:],
    "",
    ("bits=", "debug", "endian=", "raw"),
  )
if len(args) not in (1, 2) :
    raise getopt.GetoptError("usage: %s blendfile [outfile]" % sys.argv[0])
#end if
bit64 = None
big_endian = None
debug = False
use_rawdata = False
for keyword, value in opts :
    if keyword == "--bits" :
        bit64 = {32 : False, 64 : True}[int(value)]
    elif keyword == "--debug" :
        debug = True
    elif keyword == "--endian" :
        big_endian = {"big" : True, "little" : False}[value.lower()]
    elif keyword == "--raw" :
        use_rawdata = True
    #end if
#end for
if debug :
    log = sys.stdout
else :
    log = None
#end if
blend = blendfile.Blenddata().load(args[0], keep_rawdata = use_rawdata, count_refs = True, log = log)
if log != None :
    for i, block in enumerate(blend.blocks) :
        if block["decoded"] :
            log.write("block %d(%s)[%s]@%#x : %s[%d]\n" % (i, repr(block["code"]), len(block.get("rawdata", "")), block["oldaddr"], block["type"]["name"], block["dna_count"])) # debug
            if block.get("refs") == 0 :
                log.write(" - no refs to this block\n")
            #end if
            for item in block["data"] :
                log.write(" => " + dict_repr(item) + "\n")
            #end for
        #end if
    #end for
#end if
if len(args) > 1 :
    remap = {}
      # try fiddling with address fields
    def remap_addr(addr) :
        if addr not in remap :
            remap[addr] = len(remap) + 1
        #end if
        return \
            remap[addr]
    #end remap_addr

    def remap_block(block) :

        def remap_refs(data, datatype) :
            result = data # initial assumption
            if type(datatype) == blendfile.PointerType :
                if type(data) == blendfile.DanglingPointer :
                    data.addr = remap_addr(data.addr)
                elif type(data) == blendfile.BlockRef :
                    data.block["index"] = remap_addr(data.block["index"])
                #end if
            elif type(datatype) == blendfile.FixedArrayType :
                if datatype.EltType != blend.types["char"] :
                    for i in range(len(data)) :
                        remap_refs(data[i], datatype.EltType)
                    #end for
                #end if
            elif type(datatype) == blendfile.MethodType :
                pass
            elif datatype["name"] in blendfile.primitive_types :
                pass
            elif "fields" in datatype :
                for field in datatype["fields"] :
                    remap_refs \
                      (
                        (data.__getitem__, data.get)[datatype == blend.link_type](field["name"]),
                        field["type"]
                      )
                #end for
            #end if
        #end remap_refs

    #begin remap_block
        if "data" in block :
            datatype = blend.structs_by_index[block["dna_index"]]
            for i in range(len(block["data"])) :
                remap_refs(block["data"][i], datatype)
            #end for
        #end if
    #end remap_block

    for block in blend.blocks :
        remap_addr(block["oldaddr"])
    #end for
    for block in blend.blocks :
        remap_block(block)
    #end for

    if True :
        blend.save \
          (
            filename = args[1],
            bit64 = bit64,
            big_endian = big_endian,
            encode_ref = lambda block : block["index"],
            use_rawdata = use_rawdata,
            log = log,
          )
    else :
        # trying to figure out why Blender crashes, so start with exact
        # recreation of original file and work back from there
        outfile = open(args[1], "wb")
        outfile.write \
          (
                blendfile.blender_sig
            +
                {4 : b"_", 8 : b"-"}[blend.ptrsize]
            +
                {False : b"v", True : b"V"}[blend.big_endian]
            +
                blend.version
          )
        for block in blend.blocks :
            data = blend.construct_block \
              (
                block["code"],
                remap[block["oldaddr"]],
                  # also using original oldaddr works
                block["dna_index"],
                block["dna_count"],
                (
                    lambda : block["rawdata"],
                    lambda : blend.encode_data(block),
                )[block["decoded"]]()
              )
            outfile.write(data)
        #end for
        outfile.write \
          (
            blend.construct_block(b"DNA1", 0, 0, 1, blend.encode_sdna())
          )
        outfile.write \
          (
            blend.construct_block(b"ENDB", 0, 0, 0, b"")
          )
        outfile.flush()
        outfile.close()
    #end if
#end if
